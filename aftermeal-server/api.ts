/* tslint:disable */
/* eslint-disable */
/**
 * Aftermeal API Docs
 * 에프터밀 API 엔드포인트(Endpoint)와 객체 정보, 파라미터, 요청 및 응답 예제를 살펴보세요.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActivityCreatationRequest
 */
export interface ActivityCreatationRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivityCreatationRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActivityCreatationRequest
     */
    'maxParticipants'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityCreatationRequest
     */
    'location'?: ActivityCreatationRequestLocationEnum;
}

export const ActivityCreatationRequestLocationEnum = {
    Auditorium: 'AUDITORIUM',
    Ground: 'GROUND'
} as const;

export type ActivityCreatationRequestLocationEnum = typeof ActivityCreatationRequestLocationEnum[keyof typeof ActivityCreatationRequestLocationEnum];

/**
 * 
 * @export
 * @interface ActivityListResponse
 */
export interface ActivityListResponse {
    /**
     * 
     * @type {number}
     * @memberof ActivityListResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityListResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityListResponse
     */
    'location'?: ActivityListResponseLocationEnum;
    /**
     * 
     * @type {number}
     * @memberof ActivityListResponse
     */
    'maxParticipants'?: number;
}

export const ActivityListResponseLocationEnum = {
    Auditorium: 'AUDITORIUM',
    Ground: 'GROUND'
} as const;

export type ActivityListResponseLocationEnum = typeof ActivityListResponseLocationEnum[keyof typeof ActivityListResponseLocationEnum];

/**
 * 
 * @export
 * @interface ActivityScheduleListResponse
 */
export interface ActivityScheduleListResponse {
    /**
     * 
     * @type {number}
     * @memberof ActivityScheduleListResponse
     */
    'activityScheduleId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityScheduleListResponse
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActivityScheduleListResponse
     */
    'maxParticipants'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActivityScheduleListResponse
     */
    'currentParticipants'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityScheduleListResponse
     */
    'status'?: ActivityScheduleListResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ActivityScheduleListResponse
     */
    'type'?: ActivityScheduleListResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ActivityScheduleListResponse
     */
    'scheduledDate'?: string;
}

export const ActivityScheduleListResponseStatusEnum = {
    Scheduled: 'SCHEDULED',
    InProgress: 'IN_PROGRESS',
    Canceled: 'CANCELED',
    Completed: 'COMPLETED'
} as const;

export type ActivityScheduleListResponseStatusEnum = typeof ActivityScheduleListResponseStatusEnum[keyof typeof ActivityScheduleListResponseStatusEnum];
export const ActivityScheduleListResponseTypeEnum = {
    Lunch: 'LUNCH',
    Dinner: 'DINNER'
} as const;

export type ActivityScheduleListResponseTypeEnum = typeof ActivityScheduleListResponseTypeEnum[keyof typeof ActivityScheduleListResponseTypeEnum];

/**
 * 
 * @export
 * @interface ActivityScheduleResponse
 */
export interface ActivityScheduleResponse {
    /**
     * 
     * @type {number}
     * @memberof ActivityScheduleResponse
     */
    'activityScheduleId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityScheduleResponse
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActivityScheduleResponse
     */
    'maxParticipants'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityScheduleResponse
     */
    'status'?: ActivityScheduleResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ActivityScheduleResponse
     */
    'type'?: ActivityScheduleResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ActivityScheduleResponse
     */
    'scheduledDate'?: string;
    /**
     * 
     * @type {Array<ActivityScheduleResponseParticipantsInner>}
     * @memberof ActivityScheduleResponse
     */
    'participants'?: Array<ActivityScheduleResponseParticipantsInner>;
}

export const ActivityScheduleResponseStatusEnum = {
    Scheduled: 'SCHEDULED',
    InProgress: 'IN_PROGRESS',
    Canceled: 'CANCELED',
    Completed: 'COMPLETED'
} as const;

export type ActivityScheduleResponseStatusEnum = typeof ActivityScheduleResponseStatusEnum[keyof typeof ActivityScheduleResponseStatusEnum];
export const ActivityScheduleResponseTypeEnum = {
    Lunch: 'LUNCH',
    Dinner: 'DINNER'
} as const;

export type ActivityScheduleResponseTypeEnum = typeof ActivityScheduleResponseTypeEnum[keyof typeof ActivityScheduleResponseTypeEnum];

/**
 * 
 * @export
 * @interface ActivityScheduleResponseParticipantsInner
 */
export interface ActivityScheduleResponseParticipantsInner {
    /**
     * 
     * @type {number}
     * @memberof ActivityScheduleResponseParticipantsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityScheduleResponseParticipantsInner
     */
    'displayName'?: string;
}
/**
 * 
 * @export
 * @interface ActivityScheduleStatusUpdate
 */
export interface ActivityScheduleStatusUpdate {
    /**
     * 
     * @type {string}
     * @memberof ActivityScheduleStatusUpdate
     */
    'status'?: ActivityScheduleStatusUpdateStatusEnum;
}

export const ActivityScheduleStatusUpdateStatusEnum = {
    Scheduled: 'SCHEDULED',
    InProgress: 'IN_PROGRESS',
    Canceled: 'CANCELED',
    Completed: 'COMPLETED'
} as const;

export type ActivityScheduleStatusUpdateStatusEnum = typeof ActivityScheduleStatusUpdateStatusEnum[keyof typeof ActivityScheduleStatusUpdateStatusEnum];

/**
 * 
 * @export
 * @interface ActivityUpdateRequest
 */
export interface ActivityUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivityUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActivityUpdateRequest
     */
    'maxParticipants'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityUpdateRequest
     */
    'location'?: ActivityUpdateRequestLocationEnum;
}

export const ActivityUpdateRequestLocationEnum = {
    Auditorium: 'AUDITORIUM',
    Ground: 'GROUND'
} as const;

export type ActivityUpdateRequestLocationEnum = typeof ActivityUpdateRequestLocationEnum[keyof typeof ActivityUpdateRequestLocationEnum];

/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'tokenType'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginResponse
     */
    'expiredIn'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {LoginResponseUser}
     * @memberof LoginResponse
     */
    'user'?: LoginResponseUser;
}
/**
 * 
 * @export
 * @interface LoginResponseUser
 */
export interface LoginResponseUser {
    /**
     * 
     * @type {string}
     * @memberof LoginResponseUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseUser
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoginResponseUser
     */
    'roles'?: Array<LoginResponseUserRolesEnum>;
}

export const LoginResponseUserRolesEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type LoginResponseUserRolesEnum = typeof LoginResponseUserRolesEnum[keyof typeof LoginResponseUserRolesEnum];

/**
 * 
 * @export
 * @interface UserListResponse
 */
export interface UserListResponse {
    /**
     * 
     * @type {number}
     * @memberof UserListResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserListResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserListResponse
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserListResponse
     */
    'roles'?: Array<UserListResponseRolesEnum>;
    /**
     * 
     * @type {string}
     * @memberof UserListResponse
     */
    'type'?: UserListResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserListResponse
     */
    'status'?: UserListResponseStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof UserListResponse
     */
    'generationNumber'?: number;
}

export const UserListResponseRolesEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type UserListResponseRolesEnum = typeof UserListResponseRolesEnum[keyof typeof UserListResponseRolesEnum];
export const UserListResponseTypeEnum = {
    Student: 'STUDENT',
    Teacher: 'TEACHER'
} as const;

export type UserListResponseTypeEnum = typeof UserListResponseTypeEnum[keyof typeof UserListResponseTypeEnum];
export const UserListResponseStatusEnum = {
    Activate: 'ACTIVATE',
    Deactivate: 'DEACTIVATE'
} as const;

export type UserListResponseStatusEnum = typeof UserListResponseStatusEnum[keyof typeof UserListResponseStatusEnum];

/**
 * 
 * @export
 * @interface UserUpdateRequest
 */
export interface UserUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'type'?: UserUpdateRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'status'?: UserUpdateRequestStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof UserUpdateRequest
     */
    'generationNumber'?: number;
}

export const UserUpdateRequestTypeEnum = {
    Student: 'STUDENT',
    Teacher: 'TEACHER'
} as const;

export type UserUpdateRequestTypeEnum = typeof UserUpdateRequestTypeEnum[keyof typeof UserUpdateRequestTypeEnum];
export const UserUpdateRequestStatusEnum = {
    Activate: 'ACTIVATE',
    Deactivate: 'DEACTIVATE'
} as const;

export type UserUpdateRequestStatusEnum = typeof UserUpdateRequestStatusEnum[keyof typeof UserUpdateRequestStatusEnum];


/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 활동 삭제
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesActivityIdDelete: async (activityId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('activitiesActivityIdDelete', 'activityId', activityId)
            const localVarPath = `/activities/{activityId}`
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 활동 수정
         * @param {number} activityId 
         * @param {ActivityUpdateRequest} activityUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesActivityIdPut: async (activityId: number, activityUpdateRequest: ActivityUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('activitiesActivityIdPut', 'activityId', activityId)
            // verify required parameter 'activityUpdateRequest' is not null or undefined
            assertParamExists('activitiesActivityIdPut', 'activityUpdateRequest', activityUpdateRequest)
            const localVarPath = `/activities/{activityId}`
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 활동 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 활동 생성
         * @param {ActivityCreatationRequest} activityCreatationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesPost: async (activityCreatationRequest: ActivityCreatationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityCreatationRequest' is not null or undefined
            assertParamExists('activitiesPost', 'activityCreatationRequest', activityCreatationRequest)
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityCreatationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 활동 삭제
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitiesActivityIdDelete(activityId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitiesActivityIdDelete(activityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitiesApi.activitiesActivityIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 활동 수정
         * @param {number} activityId 
         * @param {ActivityUpdateRequest} activityUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitiesActivityIdPut(activityId: number, activityUpdateRequest: ActivityUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitiesActivityIdPut(activityId, activityUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitiesApi.activitiesActivityIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 활동 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitiesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityListResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitiesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitiesApi.activitiesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 활동 생성
         * @param {ActivityCreatationRequest} activityCreatationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitiesPost(activityCreatationRequest: ActivityCreatationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitiesPost(activityCreatationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitiesApi.activitiesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary 활동 삭제
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesActivityIdDelete(activityId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.activitiesActivityIdDelete(activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 활동 수정
         * @param {number} activityId 
         * @param {ActivityUpdateRequest} activityUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesActivityIdPut(activityId: number, activityUpdateRequest: ActivityUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.activitiesActivityIdPut(activityId, activityUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 활동 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ActivityListResponse>> {
            return localVarFp.activitiesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 활동 생성
         * @param {ActivityCreatationRequest} activityCreatationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesPost(activityCreatationRequest: ActivityCreatationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.activitiesPost(activityCreatationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * 
     * @summary 활동 삭제
     * @param {number} activityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public activitiesActivityIdDelete(activityId: number, options?: RawAxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).activitiesActivityIdDelete(activityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 활동 수정
     * @param {number} activityId 
     * @param {ActivityUpdateRequest} activityUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public activitiesActivityIdPut(activityId: number, activityUpdateRequest: ActivityUpdateRequest, options?: RawAxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).activitiesActivityIdPut(activityId, activityUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 활동 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public activitiesGet(options?: RawAxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).activitiesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 활동 생성
     * @param {ActivityCreatationRequest} activityCreatationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public activitiesPost(activityCreatationRequest: ActivityCreatationRequest, options?: RawAxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).activitiesPost(activityCreatationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ActivitySchedulesApi - axios parameter creator
 * @export
 */
export const ActivitySchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 활동 일정 상세 조회
         * @param {number} activityScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitySchedulesActivityScheduleIdGet: async (activityScheduleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityScheduleId' is not null or undefined
            assertParamExists('activitySchedulesActivityScheduleIdGet', 'activityScheduleId', activityScheduleId)
            const localVarPath = `/activity-schedules/{activityScheduleId}`
                .replace(`{${"activityScheduleId"}}`, encodeURIComponent(String(activityScheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 활동 일정 상태 수정
         * @param {number} activityScheduleId 
         * @param {ActivityScheduleStatusUpdate} activityScheduleStatusUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitySchedulesActivityScheduleIdStatusPatch: async (activityScheduleId: number, activityScheduleStatusUpdate: ActivityScheduleStatusUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityScheduleId' is not null or undefined
            assertParamExists('activitySchedulesActivityScheduleIdStatusPatch', 'activityScheduleId', activityScheduleId)
            // verify required parameter 'activityScheduleStatusUpdate' is not null or undefined
            assertParamExists('activitySchedulesActivityScheduleIdStatusPatch', 'activityScheduleStatusUpdate', activityScheduleStatusUpdate)
            const localVarPath = `/activity-schedules/{activityScheduleId}/status`
                .replace(`{${"activityScheduleId"}}`, encodeURIComponent(String(activityScheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityScheduleStatusUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 활동 일정 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitySchedulesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activity-schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitySchedulesApi - functional programming interface
 * @export
 */
export const ActivitySchedulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivitySchedulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 활동 일정 상세 조회
         * @param {number} activityScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitySchedulesActivityScheduleIdGet(activityScheduleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityScheduleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitySchedulesActivityScheduleIdGet(activityScheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitySchedulesApi.activitySchedulesActivityScheduleIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 활동 일정 상태 수정
         * @param {number} activityScheduleId 
         * @param {ActivityScheduleStatusUpdate} activityScheduleStatusUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitySchedulesActivityScheduleIdStatusPatch(activityScheduleId: number, activityScheduleStatusUpdate: ActivityScheduleStatusUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitySchedulesActivityScheduleIdStatusPatch(activityScheduleId, activityScheduleStatusUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitySchedulesApi.activitySchedulesActivityScheduleIdStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 활동 일정 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitySchedulesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityScheduleListResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitySchedulesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitySchedulesApi.activitySchedulesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivitySchedulesApi - factory interface
 * @export
 */
export const ActivitySchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitySchedulesApiFp(configuration)
    return {
        /**
         * 
         * @summary 활동 일정 상세 조회
         * @param {number} activityScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitySchedulesActivityScheduleIdGet(activityScheduleId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ActivityScheduleResponse>> {
            return localVarFp.activitySchedulesActivityScheduleIdGet(activityScheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 활동 일정 상태 수정
         * @param {number} activityScheduleId 
         * @param {ActivityScheduleStatusUpdate} activityScheduleStatusUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitySchedulesActivityScheduleIdStatusPatch(activityScheduleId: number, activityScheduleStatusUpdate: ActivityScheduleStatusUpdate, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.activitySchedulesActivityScheduleIdStatusPatch(activityScheduleId, activityScheduleStatusUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 활동 일정 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitySchedulesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ActivityScheduleListResponse>> {
            return localVarFp.activitySchedulesGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivitySchedulesApi - object-oriented interface
 * @export
 * @class ActivitySchedulesApi
 * @extends {BaseAPI}
 */
export class ActivitySchedulesApi extends BaseAPI {
    /**
     * 
     * @summary 활동 일정 상세 조회
     * @param {number} activityScheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitySchedulesApi
     */
    public activitySchedulesActivityScheduleIdGet(activityScheduleId: number, options?: RawAxiosRequestConfig) {
        return ActivitySchedulesApiFp(this.configuration).activitySchedulesActivityScheduleIdGet(activityScheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 활동 일정 상태 수정
     * @param {number} activityScheduleId 
     * @param {ActivityScheduleStatusUpdate} activityScheduleStatusUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitySchedulesApi
     */
    public activitySchedulesActivityScheduleIdStatusPatch(activityScheduleId: number, activityScheduleStatusUpdate: ActivityScheduleStatusUpdate, options?: RawAxiosRequestConfig) {
        return ActivitySchedulesApiFp(this.configuration).activitySchedulesActivityScheduleIdStatusPatch(activityScheduleId, activityScheduleStatusUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 활동 일정 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitySchedulesApi
     */
    public activitySchedulesGet(options?: RawAxiosRequestConfig) {
        return ActivitySchedulesApiFp(this.configuration).activitySchedulesGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 로그인
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('authLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 로그인
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary 로그인
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary 로그인
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ParticipationsApi - axios parameter creator
 * @export
 */
export const ParticipationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 참가자 제외
         * @param {number} participationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participationsParticipationIdExcludePost: async (participationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'participationId' is not null or undefined
            assertParamExists('participationsParticipationIdExcludePost', 'participationId', participationId)
            const localVarPath = `/participations/{participationId}/exclude`
                .replace(`{${"participationId"}}`, encodeURIComponent(String(participationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParticipationsApi - functional programming interface
 * @export
 */
export const ParticipationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParticipationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 참가자 제외
         * @param {number} participationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async participationsParticipationIdExcludePost(participationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.participationsParticipationIdExcludePost(participationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipationsApi.participationsParticipationIdExcludePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ParticipationsApi - factory interface
 * @export
 */
export const ParticipationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParticipationsApiFp(configuration)
    return {
        /**
         * 
         * @summary 참가자 제외
         * @param {number} participationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participationsParticipationIdExcludePost(participationId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.participationsParticipationIdExcludePost(participationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParticipationsApi - object-oriented interface
 * @export
 * @class ParticipationsApi
 * @extends {BaseAPI}
 */
export class ParticipationsApi extends BaseAPI {
    /**
     * 
     * @summary 참가자 제외
     * @param {number} participationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipationsApi
     */
    public participationsParticipationIdExcludePost(participationId: number, options?: RawAxiosRequestConfig) {
        return ParticipationsApiFp(this.configuration).participationsParticipationIdExcludePost(participationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 사용자 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 삭제
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDelete: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdDelete', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 수정
         * @param {number} userId 
         * @param {UserUpdateRequest} userUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPut: async (userId: number, userUpdateRequest: UserUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdPut', 'userId', userId)
            // verify required parameter 'userUpdateRequest' is not null or undefined
            assertParamExists('usersUserIdPut', 'userUpdateRequest', userUpdateRequest)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 사용자 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserListResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 사용자 삭제
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdDelete(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdDelete(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersUserIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 사용자 수정
         * @param {number} userId 
         * @param {UserUpdateRequest} userUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdPut(userId: number, userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdPut(userId, userUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersUserIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary 사용자 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserListResponse>> {
            return localVarFp.usersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 삭제
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDelete(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersUserIdDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 수정
         * @param {number} userId 
         * @param {UserUpdateRequest} userUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPut(userId: number, userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersUserIdPut(userId, userUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary 사용자 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 삭제
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdDelete(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 수정
     * @param {number} userId 
     * @param {UserUpdateRequest} userUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdPut(userId: number, userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdPut(userId, userUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



